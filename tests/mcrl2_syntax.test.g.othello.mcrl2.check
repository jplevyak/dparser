4737 states 2848 scans 2848 shifts 3510 reductions 1 compares 0 ambiguities
((( sort (( Player  = ( struct (( red )( | ( white )))) ; )( Square  = ( struct (( piece ( ( (( Player )) ) ))(( | ( empty ))( | ( invalid ))))) ; )( Outcome  = ( struct (( win ( ( (( Player )) ) ))( | ( draw )))) ; )( Direction  = ( List  (  Int  ) ) ; )( Row  = ( List  (  Square  ) ) ; )( Board  = ( List  (  Row  ) ) ; )))( map (((( N (( ,  M )( ,  R )( ,  C ))) :  Pos ) ; )((( B ) :  Board ) ; )((( alldirections ) : ( List  (  Direction  ) )) ; )((( outcome ) : ( Board  ->  Outcome )) ; )((( ccount ) : (( Board  #  Player ) ->  Nat )) ; )((( ccount ) : (( Row  #  Player ) ->  Nat )) ; )((( canplay ) : (((( Board  #  Nat ) #  Nat ) #  Player ) ->  Bool )) ; )((( at ) : ((( Board  #  Int ) #  Int ) ->  Square )) ; )((( updated ) : ((((( Board  #  Nat ) #  Nat ) #  Player ) #  Direction ) ->  Board )) ; )((( update ) : ((((( Board  #  Nat ) #  Nat ) #  Player ) # ( List  (  Direction  ) )) ->  Board )) ; )((( update ) : (((( Board  #  Nat ) #  Nat ) #  Player ) ->  Board )) ; )((( replace ) : (((( Board  #  Nat ) #  Nat ) #  Player ) ->  Board )) ; )((( replace ) : ((( Row  #  Nat ) #  Player ) ->  Row )) ; )((( nextn ( ,  nextm )) : (( Nat  #  Direction ) ->  Nat )) ; )((( opponent ) : ( Player  ->  Player )) ; )((( pad ) : (( Row  #  Nat ) ->  Row )) ; )((( pad ) : (( Board  #  Nat ) ->  Board )) ; )))(( var ((((( n ( ,  m )) :  Nat )) ; )(((( i ( ,  j )) :  Int )) ; )(((( b ) :  Board )) ; )(((( r ) :  Row )) ; )(((( s ) :  Square )) ; )(((( P ) :  Player )) ; )(((( d ) :  Direction )) ; )(((( l ) : ( List  (  Direction  ) ))) ; ))) eqn (( alldirections  = ( [ (( [ ( 0 ( ,  1 )) ] )(( , ( [ ( 1 ( ,  1 )) ] ))( , ( [ ( 1 ( ,  0 )) ] ))( , ( [ ( 1 ( , ( -  1 ))) ] ))( , ( [ ( 0 ( , ( -  1 ))) ] ))( , ( [ (( -  1 )( , ( -  1 ))) ] ))( , ( [ (( -  1 )( ,  0 )) ] ))( , ( [ (( -  1 )( ,  1 )) ] )))) ] ) ; )(((( 0  <=  i ) && (( i  <  N ) && (( 0  <=  j ) && ( j  <  M )))) -> )( at  ( ( b (( ,  i )( ,  j ))) ) ) = (( b  . ( Int2Nat  ( ( i ) ) )) . ( Int2Nat  ( ( j ) ) )) ; )(((( 0  >  i ) || (( i  >=  N ) || (( 0  >  j ) || ( j  >=  M )))) -> )( at  ( ( b (( ,  i )( ,  j ))) ) ) =  invalid  ; )(( outcome  ( ( b ) ) ) = (( if  ( (( i  ==  j )(( ,  draw )( , ( if  ( (( i  >  j )(( , ( win  ( ( red ) ) ))( , ( win  ( ( white ) ) )))) ) )))) ) ) whr (( i  = ( Nat2Int  ( (( ccount  ( ( b ( ,  red )) ) )) ) ))( , ( j  = ( Nat2Int  ( (( ccount  ( ( b ( ,  white )) ) )) ) )))) end ) ; )(( ccount  ( (( r  |>  b )( ,  P )) ) ) = (( ccount  ( ( r ( ,  P )) ) ) + ( ccount  ( ( b ( ,  P )) ) )) ; )((( b  == ( [  ] )) -> )( ccount  ( ( b ( ,  P )) ) ) =  0  ; )((( s  == ( piece  ( ( P ) ) )) -> )( ccount  ( (( s  |>  r )( ,  P )) ) ) = (( ccount  ( ( r ( ,  P )) ) ) +  1 ) ; )((( s  != ( piece  ( ( P ) ) )) -> )( ccount  ( (( s  |>  r )( ,  P )) ) ) = ( ccount  ( ( r ( ,  P )) ) ) ; )((( r  == ( [  ] )) -> )( ccount  ( ( r ( ,  P )) ) ) =  0  ; )(( canplay  ( ( b (( ,  n )( ,  m )( ,  P ))) ) ) = ((( at  ( ( b (( ,  n )( ,  m ))) ) ) ==  empty ) && (( update  ( ( b (( ,  n )( ,  m )( ,  P ))) ) ) !=  b )) ; )(( update  ( ( b (( ,  n )( ,  m )( ,  P ))) ) ) = ( update  ( ( b (( ,  n )( ,  m )( ,  P )( ,  alldirections ))) ) ) ; )(((( at  ( ( b (( , ( n  + ( d  .  0 )))( , ( m  + ( d  .  1 ))))) ) ) == ( piece  ( (( opponent  ( ( P ) ) )) ) )) -> )( update  ( ( b (( ,  n )( ,  m )( ,  P )( , ( d  |>  l )))) ) ) = (( if  ( (( newboard  !=  b )(( , ( update  ( (( replace  ( ( newboard (( ,  n )( ,  m )( ,  P ))) ) )(( ,  n )( ,  m )( ,  P )( ,  l ))) ) ))( , ( update  ( ( b (( ,  n )( ,  m )( ,  P )( ,  l ))) ) )))) ) ) whr (( newboard  = ( updated  ( ( b (( ,  n )( ,  m )( ,  P )( ,  d ))) ) ))) end ) ; )(((( at  ( ( b (( , ( n  + ( d  .  0 )))( , ( m  + ( d  .  1 ))))) ) ) != ( piece  ( (( opponent  ( ( P ) ) )) ) )) -> )( update  ( ( b (( ,  n )( ,  m )( ,  P )( , ( d  |>  l )))) ) ) = ( update  ( ( b (( ,  n )( ,  m )( ,  P )( ,  l ))) ) ) ; )(( update  ( ( b (( ,  n )( ,  m )( ,  P )( , ( [  ] )))) ) ) =  b  ; )((( ( (( ( (( lookahead  ==  empty ) || ( lookahead  ==  invalid )) ) ) whr (( lookahead  = ( at  ( ( b (( , ( n  + ( d  .  0 )))( , ( m  + ( d  .  1 ))))) ) ))) end ) ) ) -> )( updated  ( ( b (( ,  n )( ,  m )( ,  P )( ,  d ))) ) ) =  b  ; )((( ( (( lookahead  == ( piece  ( ( P ) ) )) whr (( lookahead  = ( at  ( ( b (( , ( n  + ( d  .  0 )))( , ( m  + ( d  .  1 ))))) ) ))) end ) ) ) -> )( updated  ( ( b (( ,  n )( ,  m )( ,  P )( ,  d ))) ) ) = ( replace  ( ( b (( ,  n )( ,  m )( ,  P ))) ) ) ; )((( ( (( ( (( lookahead  !=  empty ) && (( lookahead  !=  invalid ) && ( lookahead  != ( piece  ( ( P ) ) )))) ) ) whr (( lookahead  = ( at  ( ( b (( , ( n  + ( d  .  0 )))( , ( m  + ( d  .  1 ))))) ) ))) end ) ) ) -> )( updated  ( ( b (( ,  n )( ,  m )( ,  P )( ,  d ))) ) ) = ( updated  ( ( b (( , ( Int2Nat  ( (( n  + ( d  .  0 ))) ) ))( , ( Int2Nat  ( (( m  + ( d  .  1 ))) ) ))( ,  P )( ,  d ))) ) ) ; )((( n  >  0 ) -> )( replace  ( (( r  |>  b )(( ,  n )( ,  m )( ,  P ))) ) ) = ( r  |> ( replace  ( ( b (( , ( Int2Nat  ( (( n  -  1 )) ) ))( ,  m )( ,  P ))) ) )) ; )((( n  ==  0 ) -> )( replace  ( (( r  |>  b )(( ,  n )( ,  m )( ,  P ))) ) ) = (( replace  ( ( r (( ,  m )( ,  P ))) ) ) |>  b ) ; )((( m  >  0 ) -> )( replace  ( (( s  |>  r )(( ,  m )( ,  P ))) ) ) = ( s  |> ( replace  ( ( r (( , ( Int2Nat  ( (( m  -  1 )) ) ))( ,  P ))) ) )) ; )((( m  ==  0 ) -> )( replace  ( (( s  |>  r )(( ,  m )( ,  P ))) ) ) = (( piece  ( ( P ) ) ) |>  r ) ; )(( opponent  ( ( red ) ) ) =  white  ; )(( opponent  ( ( white ) ) ) =  red  ; )( B  = ( pad  ( (( [ (( pad  ( (( [ (( piece  ( ( red ) ) )( , ( piece  ( ( white ) ) ))) ] )( ,  0 )) ) )( , ( pad  ( (( [ (( piece  ( ( white ) ) )( , ( piece  ( ( red ) ) ))) ] )( ,  0 )) ) ))) ] )( ,  0 )) ) ) ; )( R  =  1  ; )( C  =  1  ; )( N  = (( 2  *  R ) +  2 ) ; )( M  = (( 2  *  C ) +  2 ) ; )((( n  <  C ) -> )( pad  ( ( r ( ,  n )) ) ) = ( pad  ( (( empty  |> ( r  <|  empty ))( , ( n  +  1 ))) ) ) ; )((( n  ==  C ) -> )( pad  ( ( r ( ,  n )) ) ) =  r  ; )((( n  <  C ) -> )( pad  ( ( b ( ,  n )) ) ) = (( pad  ( (( r  |> ( b  <|  r ))( , ( n  +  1 ))) ) ) whr (( r  = ( pad  ( (( [ ( empty ( ,  empty )) ] )( ,  0 )) ) ))) end ) ; )((( n  ==  C ) -> )( pad  ( ( b ( ,  n )) ) ) =  b  ; )))( act ((( Put )( : (( Nat  #  Nat ) #  Player )) ; )(( Outcome )( :  Outcome ) ; )(( Pass ) ; )))( proc ( Othello ( ( ((( board ) :  Board )(( , (( turn ) :  Player ))( , (( canpass ) :  Bool )))) ) ) = (((( sum ((( n ( ,  m )) :  Nat )) . (( canplay  ( ( board (( ,  n )( ,  m )( ,  turn ))) ) ) -> (( Put ( ( ( n (( ,  m )( ,  turn ))) ) )) . ( Othello ( ( (( update  ( ( board (( ,  n )( ,  m )( ,  turn ))) ) )(( , ( opponent  ( ( turn ) ) ))( ,  true ))) ) ))))) + (( ( ( canpass  && ( ! ( exists ((( n ( ,  m )) :  Nat )) . ( canplay  ( ( board (( ,  n )( ,  m )( ,  turn ))) ) )))) ) ) -> (( Pass ) . ( Othello ( ( ( board (( , ( opponent  ( ( turn ) ) ))( ,  false ))) ) ))))) + (( ( (( !  canpass ) && ( ! ( exists ((( n ( ,  m )) :  Nat )) . ( canplay  ( ( board (( ,  n )( ,  m )( ,  turn ))) ) )))) ) ) -> (( Outcome ( ( (( outcome  ( ( board ) ) )) ) )) . ( Othello  (  ) )))) +  delta ) ; )))( init ( Othello ( ( ( B (( ,  red )( ,  true ))) ) )) ; ))
